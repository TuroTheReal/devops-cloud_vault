# Terraform Fundamentals - Infrastructure as Code

## üìã Metadata

```yaml
tags: [concept, terraform, iac, aws, status/learned]
created: 2025-01-21
difficulty: ‚≠ê‚≠ê‚≠ê‚≠ê (4/5)
time-to-master: 15h
```

**Prerequisites**: [[concepts/linux/linux-basics]]
**Related to**: [[concepts/ansible/ansible-fundamentals]], [[concepts/aws/aws-fundamentals]]
**Official docs**: [Terraform Docs](https://developer.hashicorp.com/terraform/docs) | [Registry (Providers/Modules)](https://registry.terraform.io/)

---

## üéØ TL;DR (30 seconds)

Terraform creates and manages cloud infrastructure through declarative code. You describe what you WANT, Terraform figures out how to get there and applies the changes.

**Analogy**: If Ansible decorates and furnishes the house, Terraform is the architect who compares blueprints (.tf files) with the land registry (tfstate) to determine what construction work needs to be done.

---

## ü§î When to Use?

### ‚úÖ Good for
1. **Reproducible infrastructure**: Create identical dev/staging/prod environments
2. **Multi-cloud**: Manage AWS, GCP, Azure with the same tool
3. **Infrastructure versioning**: Git for your infrastructure, rollback possible

### ‚ùå Bad for
- **Server configuration** ‚Üí Use [[concepts/ansible/ansible-fundamentals]] instead
- **One-shot manual setup** ‚Üí AWS Console faster for quick tests

---

## üìö Key Concepts

### 1. The Workflow (init ‚Üí plan ‚Üí apply ‚Üí destroy)

**My understanding**:
This is the lifecycle of your infrastructure. Each command has a specific role:
- `init`: Prepare the worksite (download providers). **Run again when**: adding/changing providers, changing backend, cloning repo on new machine
- `plan`: Compare blueprints vs reality, show the diff
- `apply`: Execute the work **AND update tfstate**
- `destroy`: Complete demolition

**Why important**:
Understanding this flow prevents 90% of errors. You never rush in blindly.

**Mental model**:
```
init    = hire the contractors (download providers)
plan    = compare blueprints vs land registry (diff)
apply   = do the work + update land registry (creates/updates tfstate)
destroy = demolition + clear land registry
```

---

### 2. The State (terraform.tfstate)

**My understanding**:
The tfstate is the "land registry" of your infrastructure. It maps what Terraform created with the actual IDs on AWS. Without it, Terraform doesn't know what exists.

**Created/Updated by**: `terraform apply` (also `terraform import` for existing resources)

**Why important**:
- No tfstate ‚Üí Terraform will recreate everything (duplicates!)
- 2 people with different tfstate ‚Üí chaos
- Remote state (S3) mandatory for teams

**Mental model**:
```
.tf files           = what you WANT
terraform.tfstate   = what actually EXISTS (updated by apply)
terraform plan      = diff between the two
```

---

### 3. Terraform Files

**My understanding**:

| File | Role |
|------|------|
| `main.tf` | Resources to create (EC2, VPC, SG...) |
| `variables.tf` | Variable declarations (the empty form) |
| `terraform.tfvars` | Variable values (the filled form) |
| `outputs.tf` | What to retrieve after apply (IPs, DNS...) |
| `.terraform.lock.hcl` | Exact provider versions (commit this) |
| `terraform.tfstate` | Current state (DON'T commit if contains secrets) |
| `.terraform/` | Downloaded providers (DON'T commit, regenerated by init) |

**Why important**:
Good organization = maintainable and secure code.

---

### 4. Providers & Modules

**My understanding**:
- **Providers**: Plugins that let Terraform talk to cloud APIs (AWS, GCP, Azure...)
- **Modules**: Reusable Terraform code packages (like Ansible roles)

**Why important**:
Don't reinvent the wheel. Use official/verified modules from the registry.

**Docs**:
- [Providers Registry](https://registry.terraform.io/browse/providers)
- [Modules Registry](https://registry.terraform.io/browse/modules)

---

### 5. Multi-instance with count

**My understanding**:
`count = X` creates X identical instances. Terraform automatically manages an index (`count.index`) to differentiate each resource.

**Why important**:
Avoids code duplication. One definition, N instances.

**Mental model**:
```hcl
resource "aws_instance" "web" {
  count = 2  # Creates 2 instances
  tags = {
    Name = "web-${count.index + 1}"  # web-1, web-2
  }
}
```

---

## üíª Minimal Example

### Context
Create an EC2 with Security Group on AWS.

### Code
```hcl
# main.tf
provider "aws" {
  region = var.aws_region
}

resource "aws_security_group" "web_sg" {
  name = "web-sg"

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["X.X.X.X/32"]  # Your IP only
  }

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {  # Outbound = traffic going OUT from instance to Internet
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

resource "aws_instance" "web" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = var.instance_type
  vpc_security_group_ids = [aws_security_group.web_sg.id]

  tags = {
    Name = "web-server"
  }
}
```

```hcl
# variables.tf
variable "aws_region" {
  default = "us-east-1"
}

variable "instance_type" {
  default = "t3.micro"
}
```

```hcl
# outputs.tf
output "public_ip" {
  value = aws_instance.web.public_ip
}
```

**Output**: `terraform output` displays the public IP of the created instance.

---

## ‚ö†Ô∏è Pitfalls Experienced

### Pitfall 1: EC2 created but not ready for SSH

**Symptom**: `Connection refused` or SSH timeout right after `terraform apply`

**What I did wrong**:
```hcl
# ‚ùå Wrong - Launch Ansible immediately after EC2 creation
resource "null_resource" "run_ansible" {
  depends_on = [aws_instance.web]  # Not enough!

  provisioner "local-exec" {
    command = "ansible-playbook playbook.yml"
  }
}
```

**Solution**:
```hcl
# ‚úÖ Correct - Wait for SSH to be actually ready
resource "null_resource" "wait_ssh" {
  depends_on = [aws_instance.web]

  provisioner "local-exec" {
    command = <<-EOT
      until ssh -o ConnectTimeout=2 -o StrictHostKeyChecking=no \
        ubuntu@${aws_instance.web.public_ip} exit 2>/dev/null; do
        sleep 5
      done
    EOT
  }
}

resource "null_resource" "run_ansible" {
  depends_on = [null_resource.wait_ssh]  # Now we actually wait
  # ...
}
```

**Time wasted**: 1h30
**Lesson**: EC2 "running" != SSH ready. Always add a wait loop.

---

## üìä Stats

```yaml
Total time: 15h (60% assisted / 40% autonomous)
Used in: [[projects/2025-01-aws-terraform-ansible/learnings]]
```

---

**Last update**: 2025-01-21
**Next review**: 2025-02-21
